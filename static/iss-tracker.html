<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ISS Orbital Tracker</title>
    <!-- Tailwind CSS for UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Anime.js for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Inter', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 1.5rem; }
        .glass-panel { background: rgba(10, 15, 25, 0.6); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 1rem; pointer-events: auto; }
        .data-value { font-family: 'Courier New', Courier, monospace; text-shadow: 0 0 10px rgba(56, 189, 248, 0.5); }
        
        /* Custom Scrollbar for potential small screens */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <!-- Header -->
        <div class="flex justify-between items-start">
            <div class="glass-panel p-4 md:p-6 w-full md:w-80 shadow-2xl">
                <div class="flex items-center gap-3 mb-4">
                    <i data-lucide="satellite" class="text-sky-400 w-6 h-6"></i>
                    <h1 class="text-xl font-bold tracking-wider text-white">ISS TRACKER</h1>
                </div>
                <div class="flex items-center gap-2 mb-6">
                    <div id="status-dot" class="w-2 h-2 rounded-full bg-emerald-400 animate-pulse shadow-[0_0_8px_#34d399]"></div>
                    <span id="status-text" class="text-xs uppercase tracking-widest text-emerald-400 font-semibold">Live Telemetry</span>
                </div>
                
                <div class="space-y-4">
                    <div>
                        <p class="text-xs text-slate-400 uppercase tracking-wider mb-1">Latitude</p>
                        <p class="text-2xl text-white data-value" id="val-lat">0.0000°</p>
                    </div>
                    <div>
                        <p class="text-xs text-slate-400 uppercase tracking-wider mb-1">Longitude</p>
                        <p class="text-2xl text-white data-value" id="val-lon">0.0000°</p>
                    </div>
                    <div class="h-px bg-white/10 my-4"></div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <p class="text-xs text-slate-400 uppercase tracking-wider mb-1">Velocity</p>
                            <p class="text-lg text-sky-300 data-value"><span id="val-vel">0</span> <span class="text-xs text-slate-500">km/h</span></p>
                        </div>
                        <div>
                            <p class="text-xs text-slate-400 uppercase tracking-wider mb-1">Altitude</p>
                            <p class="text-lg text-sky-300 data-value"><span id="val-alt">0</span> <span class="text-xs text-slate-500">km</span></p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Environment Data -->
            <div class="glass-panel p-4 hidden md:block w-64">
                <div class="flex items-center gap-2 mb-4">
                    <i data-lucide="sun" class="text-amber-400 w-5 h-5"></i>
                    <h2 class="text-sm font-bold tracking-wider text-white">SOLAR EPHEMERIS</h2>
                </div>
                <div class="space-y-3">
                    <div>
                        <p class="text-xs text-slate-400 uppercase tracking-wider">Subsolar Lat</p>
                        <p class="text-sm text-amber-200 data-value" id="val-sun-lat">0.00°</p>
                    </div>
                    <div>
                        <p class="text-xs text-slate-400 uppercase tracking-wider">Subsolar Lon</p>
                        <p class="text-sm text-amber-200 data-value" id="val-sun-lon">0.00°</p>
                    </div>
                    <div>
                        <p class="text-xs text-slate-400 uppercase tracking-wider">UTC Time</p>
                        <p class="text-sm text-slate-300 data-value" id="val-utc">00:00:00</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls Hint -->
        <div class="self-center md:self-end glass-panel px-4 py-2 flex items-center gap-3">
            <i data-lucide="mouse" class="w-4 h-4 text-slate-400"></i>
            <span class="text-xs text-slate-300 tracking-wide">Left Click: Rotate | Scroll: Zoom</span>
        </div>
    </div>

    <script>
        // Initialize Lucide Icons
        lucide.createIcons();

        // Application State
        const state = {
            iss: { lat: 0, lon: 0, altitude: 0, velocity: 0 },
            targetIss: { lat: 0, lon: 0, altitude: 0, velocity: 0 },
            sun: { lat: 0, lon: 0 },
            lastFetch: 0,
            isTracking: false
        };

        // UI Elements
        const ui = {
            lat: document.getElementById('val-lat'),
            lon: document.getElementById('val-lon'),
            vel: document.getElementById('val-vel'),
            alt: document.getElementById('val-alt'),
            sunLat: document.getElementById('val-sun-lat'),
            sunLon: document.getElementById('val-sun-lon'),
            utc: document.getElementById('val-utc'),
            statusText: document.getElementById('status-text'),
            statusDot: document.getElementById('status-dot')
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        
        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 6;
        controls.maxDistance = 25;
        controls.enablePan = false;

        // Constants
        const EARTH_RADIUS = 5;

        // --- ENVIRONMENT & LIGHTING ---
        // Ambient Light (Very dim, for the dark side of the earth)
        const ambientLight = new THREE.AmbientLight(0x111625, 0.4);
        scene.add(ambientLight);

        // Sun Light (Directional)
        const sunLight = new THREE.DirectionalLight(0xfff7e6, 1.8);
        scene.add(sunLight);

        // Starfield Background
        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const count = 1500;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const color = new THREE.Color();

            for(let i = 0; i < count; i++) {
                // Generate points on a large sphere
                const r = 100 + Math.random() * 100;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i*3+2] = r * Math.cos(phi);

                // Add slight color variation to stars
                color.setHSL(Math.random() * 0.2 + 0.5, 0.8, Math.random() * 0.5 + 0.5);
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starsMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }
        createStarfield();

        // --- EARTH ---
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);

        // Rotate Earth group to align coordinate system properly mapping Prime Meridian
        earthGroup.rotation.y = -Math.PI / 2;

        const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
        
        // High-res texture loading with robust fallback
        const textureLoader = new THREE.TextureLoader();
        const textureUrl = 'https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg';
        
        const earthMaterial = new THREE.MeshStandardMaterial({
            roughness: 0.8,
            metalness: 0.1,
            color: 0x223344 // Fallback color while loading or if it fails
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earthGroup.add(earth);

        textureLoader.load(
            textureUrl,
            function (texture) {
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                earthMaterial.map = texture;
                earthMaterial.color.setHex(0xffffff); // Reset fallback color
                earthMaterial.needsUpdate = true;
            },
            undefined,
            function (err) {
                console.warn('Could not load high-res Earth texture. Using procedural fallback colors.', err);
                earthMaterial.color.setHex(0x1a3b5c);
            }
        );

        // Premium Atmosphere (Custom Shader for Fresnel effect)
        const atmosphereGeometry = new THREE.SphereGeometry(EARTH_RADIUS * 1.02, 64, 64);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
                    gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity * 1.5;
                }
            `,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            transparent: true
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // --- ISS BEACON ---
        const issGroup = new THREE.Group();
        scene.add(issGroup);

        // Glassmorphic core
        const issGeometry = new THREE.SphereGeometry(0.08, 16, 16);
        const issMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x38bdf8,
            transmission: 0.9,
            opacity: 1,
            metalness: 0,
            roughness: 0.1,
            ior: 1.5,
            thickness: 0.5,
            emissive: 0x0ea5e9,
            emissiveIntensity: 0.5
        });
        const issMesh = new THREE.Mesh(issGeometry, issMaterial);
        issGroup.add(issMesh);

        // Performant Bloom/Glow using a Sprite
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(56, 189, 248, 1)');
            gradient.addColorStop(0.2, 'rgba(56, 189, 248, 0.8)');
            gradient.addColorStop(0.5, 'rgba(56, 189, 248, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const glowMaterial = new THREE.SpriteMaterial({
            map: createGlowTexture(),
            color: 0xffffff,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const issGlow = new THREE.Sprite(glowMaterial);
        issGlow.scale.set(0.8, 0.8, 0.8);
        issGroup.add(issGlow);

        // --- UTILITIES & MATH ---
        
        // Convert Lat/Lon to 3D Vector on the sphere
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            // Three.js standard sphere geometry orientation
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            return new THREE.Vector3(x, y, z);
        }

        // Calculate Subsolar Point (Where the sun is directly overhead)
        function calculateSolarEphemeris() {
            const now = new Date();
            
            // Format UTC Time for UI
            ui.utc.innerText = now.toISOString().substr(11, 8) + ' UTC';

            // Days since Jan 1st
            const start = new Date(now.getUTCFullYear(), 0, 0);
            const diff = now - start;
            const dayOfYear = Math.floor(diff / 86400000);

            // Declination (Latitude) - Approximate
            const declination = -23.44 * Math.cos((360 / 365) * (dayOfYear + 10) * (Math.PI / 180));
            
            // Hour Angle (Longitude)
            const utcHours = now.getUTCHours() + now.getUTCMinutes() / 60 + now.getUTCSeconds() / 3600;
            // Sun is over prime meridian at 12:00 UTC
            let longitude = 180 - (utcHours * 15);
            if (longitude < -180) longitude += 360;

            state.sun.lat = declination;
            state.sun.lon = longitude;

            // Update UI
            ui.sunLat.innerText = `${declination > 0 ? '+' : ''}${declination.toFixed(2)}°`;
            ui.sunLon.innerText = `${longitude > 0 ? '+' : ''}${longitude.toFixed(2)}°`;

            // Position Sunlight (far away)
            const sunPos = latLonToVector3(declination, longitude, EARTH_RADIUS * 10);
            sunLight.position.copy(sunPos);
        }

        // --- API & ANIMATION LOOP ---

        // Fetch data from Where The ISS At API
        async function fetchISSData() {
            try {
                const response = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                
                // Handle Longitude Wrap-around for smooth animation
                let targetLon = data.longitude;
                if (state.iss.lon > 90 && targetLon < -90) {
                    targetLon += 360;
                } else if (state.iss.lon < -90 && targetLon > 90) {
                    targetLon -= 360;
                }

                state.targetIss = {
                    lat: data.latitude,
                    lon: targetLon,
                    altitude: data.altitude,
                    velocity: data.velocity
                };

                // UI Status Update
                if (!state.isTracking) {
                    state.isTracking = true;
                    ui.statusText.innerText = "Tracking Active";
                    ui.statusText.classList.replace('text-amber-400', 'text-emerald-400');
                    ui.statusText.classList.replace('text-red-400', 'text-emerald-400');
                    ui.statusDot.classList.replace('bg-amber-400', 'bg-emerald-400');
                    ui.statusDot.classList.replace('bg-red-400', 'bg-emerald-400');
                    ui.statusDot.classList.replace('shadow-[0_0_8px_#fbbf24]', 'shadow-[0_0_8px_#34d399]');
                    ui.statusDot.classList.replace('shadow-[0_0_8px_#f87171]', 'shadow-[0_0_8px_#34d399]');
                    
                    // Initial snap
                    state.iss.lat = data.latitude;
                    state.iss.lon = data.longitude;
                    state.iss.altitude = data.altitude;
                    state.iss.velocity = data.velocity;
                }

                // Interpolate using Anime.js
                anime({
                    targets: state.iss,
                    lat: state.targetIss.lat,
                    lon: state.targetIss.lon,
                    altitude: state.targetIss.altitude,
                    velocity: state.targetIss.velocity,
                    duration: 5000, // 5 seconds to match polling
                    easing: 'linear',
                    update: function() {
                        // Update UI Numbers
                        let displayLon = state.iss.lon;
                        // Normalize longitude for display
                        while(displayLon > 180) displayLon -= 360;
                        while(displayLon < -180) displayLon += 360;

                        ui.lat.innerText = `${state.iss.lat > 0 ? '+' : ''}${state.iss.lat.toFixed(4)}°`;
                        ui.lon.innerText = `${displayLon > 0 ? '+' : ''}${displayLon.toFixed(4)}°`;
                        
                        ui.vel.innerText = Math.round(state.iss.velocity).toLocaleString();
                        ui.alt.innerText = Math.round(state.iss.altitude).toLocaleString();
                    }
                });

            } catch (error) {
                console.error("Error fetching ISS data:", error);
                ui.statusText.innerText = "Signal Lost";
                ui.statusText.classList.replace('text-emerald-400', 'text-red-400');
                ui.statusDot.classList.replace('bg-emerald-400', 'bg-red-400');
                ui.statusDot.classList.replace('shadow-[0_0_8px_#34d399]', 'shadow-[0_0_8px_#f87171]');
            }
        }

        // --- RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Rotate earth slowly (visual flair, separate from coordinate system)
            // Note: because we calculate exact coordinates based on a static earth mapping, 
            // we should not rotate the earth mesh itself, otherwise the ISS will be desynced from the texture map.
            // Clouds/Atmosphere could be rotated, but we kept it simple.

            // 1. Update Subsolar Point & Lighting constantly
            calculateSolarEphemeris();

            // 2. Update ISS 3D Position
            // Calculate a slight offset from Earth's surface based on real altitude scaled down
            const visualAltitude = EARTH_RADIUS + 0.15 + (state.iss.altitude / 10000); 
            
            // Normalize internal longitude for coordinate calculation
            let calcLon = state.iss.lon;
            while(calcLon > 180) calcLon -= 360;
            while(calcLon < -180) calcLon += 360;

            const targetPos = latLonToVector3(state.iss.lat, calcLon, visualAltitude);
            
            // The Earth group is rotated by -PI/2, we must apply this to the ISS group to sync them
            issGroup.rotation.y = earthGroup.rotation.y;
            issMesh.position.copy(targetPos);
            issGlow.position.copy(targetPos);

            // Make ISS slightly pulse
            const time = Date.now() * 0.003;
            issGlow.scale.setScalar(0.7 + Math.sin(time) * 0.1);

            controls.update();
            renderer.render(scene, camera);
        }

        // --- INITIALIZATION ---
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start App
        ui.statusText.innerText = "Connecting...";
        ui.statusText.classList.replace('text-emerald-400', 'text-amber-400');
        ui.statusDot.classList.replace('bg-emerald-400', 'bg-amber-400');
        ui.statusDot.classList.replace('shadow-[0_0_8px_#34d399]', 'shadow-[0_0_8px_#fbbf24]');

        // Initial fetch and start loop
        fetchISSData();
        setInterval(fetchISSData, 5000); // Poll every 5 seconds

        // Start render loop
        animate();

    </script>
</body>
</html>
